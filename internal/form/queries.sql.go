// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package form

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const create = `-- name: Create :one
WITH created AS (
    INSERT INTO forms (
                       title,
                       description,
                       preview_message,
                       unit_id,
                       last_editor,
                       deadline,
                       publish_time,
                       message_after_submission,
                       google_sheet_url,
                       visibility,
                       dressing_color,
                       dressing_header_font,
                       dressing_question_font,
                       dressing_text_font
                       )
    VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10,
        $11, $12, $13, $14
    )
    RETURNING id, title, description, preview_message, message_after_submission, status, unit_id, last_editor, deadline, created_at, updated_at, visibility, google_sheet_url, publish_time, cover_image_url, dressing_color, dressing_header_font, dressing_question_font, dressing_text_font
),
workflow_created AS (
    INSERT INTO workflow_versions (form_id, last_editor, workflow)
    SELECT 
        id, 
        last_editor,
        jsonb_build_array(
            jsonb_build_object(
                'id', start_node_id,
                'label', '開始表單',
                'type', 'start',
                'next', end_node_id
            ),
            jsonb_build_object(
                'id', end_node_id,
                'label', '確認/送出',
                'type', 'end'
            )
        )
    FROM created, LATERAL (
        SELECT gen_random_uuid() AS start_node_id, gen_random_uuid() AS end_node_id
    ) AS node_ids
)
SELECT 
    f.id, f.title, f.description, f.preview_message, f.message_after_submission, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at, f.visibility, f.google_sheet_url, f.publish_time, f.cover_image_url, f.dressing_color, f.dressing_header_font, f.dressing_question_font, f.dressing_text_font,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM created f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
`

type CreateParams struct {
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	PublishTime            pgtype.Timestamptz
	MessageAfterSubmission string
	GoogleSheetUrl         pgtype.Text
	Visibility             Visibility
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
}

type CreateRow struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	MessageAfterSubmission string
	Status                 Status
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Visibility             Visibility
	GoogleSheetUrl         pgtype.Text
	PublishTime            pgtype.Timestamptz
	CoverImageUrl          pgtype.Text
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
	UnitName               pgtype.Text
	OrgName                pgtype.Text
	LastEditorName         pgtype.Text
	LastEditorUsername     pgtype.Text
	LastEditorAvatarUrl    pgtype.Text
	LastEditorEmail        interface{}
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (CreateRow, error) {
	row := q.db.QueryRow(ctx, create,
		arg.Title,
		arg.Description,
		arg.PreviewMessage,
		arg.UnitID,
		arg.LastEditor,
		arg.Deadline,
		arg.PublishTime,
		arg.MessageAfterSubmission,
		arg.GoogleSheetUrl,
		arg.Visibility,
		arg.DressingColor,
		arg.DressingHeaderFont,
		arg.DressingQuestionFont,
		arg.DressingTextFont,
	)
	var i CreateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.MessageAfterSubmission,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Visibility,
		&i.GoogleSheetUrl,
		&i.PublishTime,
		&i.CoverImageUrl,
		&i.DressingColor,
		&i.DressingHeaderFont,
		&i.DressingQuestionFont,
		&i.DressingTextFont,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}

const delete = `-- name: Delete :exec
DELETE FROM forms WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const getByID = `-- name: GetByID :one
SELECT 
    f.id, f.title, f.description, f.preview_message, f.message_after_submission, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at, f.visibility, f.google_sheet_url, f.publish_time, f.cover_image_url, f.dressing_color, f.dressing_header_font, f.dressing_question_font, f.dressing_text_font,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
WHERE f.id = $1
`

type GetByIDRow struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	MessageAfterSubmission string
	Status                 Status
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Visibility             Visibility
	GoogleSheetUrl         pgtype.Text
	PublishTime            pgtype.Timestamptz
	CoverImageUrl          pgtype.Text
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
	UnitName               pgtype.Text
	OrgName                pgtype.Text
	LastEditorName         pgtype.Text
	LastEditorUsername     pgtype.Text
	LastEditorAvatarUrl    pgtype.Text
	LastEditorEmail        interface{}
}

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (GetByIDRow, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i GetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.MessageAfterSubmission,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Visibility,
		&i.GoogleSheetUrl,
		&i.PublishTime,
		&i.CoverImageUrl,
		&i.DressingColor,
		&i.DressingHeaderFont,
		&i.DressingQuestionFont,
		&i.DressingTextFont,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}

const getCoverImage = `-- name: GetCoverImage :one
SELECT image_data FROM form_covers WHERE form_id = $1
`

func (q *Queries) GetCoverImage(ctx context.Context, formID uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCoverImage, formID)
	var image_data []byte
	err := row.Scan(&image_data)
	return image_data, err
}

const list = `-- name: List :many
SELECT 
    f.id, f.title, f.description, f.preview_message, f.message_after_submission, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at, f.visibility, f.google_sheet_url, f.publish_time, f.cover_image_url, f.dressing_color, f.dressing_header_font, f.dressing_question_font, f.dressing_text_font,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
ORDER BY f.updated_at DESC
`

type ListRow struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	MessageAfterSubmission string
	Status                 Status
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Visibility             Visibility
	GoogleSheetUrl         pgtype.Text
	PublishTime            pgtype.Timestamptz
	CoverImageUrl          pgtype.Text
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
	UnitName               pgtype.Text
	OrgName                pgtype.Text
	LastEditorName         pgtype.Text
	LastEditorUsername     pgtype.Text
	LastEditorAvatarUrl    pgtype.Text
	LastEditorEmail        interface{}
}

func (q *Queries) List(ctx context.Context) ([]ListRow, error) {
	rows, err := q.db.Query(ctx, list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRow
	for rows.Next() {
		var i ListRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.PreviewMessage,
			&i.MessageAfterSubmission,
			&i.Status,
			&i.UnitID,
			&i.LastEditor,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Visibility,
			&i.GoogleSheetUrl,
			&i.PublishTime,
			&i.CoverImageUrl,
			&i.DressingColor,
			&i.DressingHeaderFont,
			&i.DressingQuestionFont,
			&i.DressingTextFont,
			&i.UnitName,
			&i.OrgName,
			&i.LastEditorName,
			&i.LastEditorUsername,
			&i.LastEditorAvatarUrl,
			&i.LastEditorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listByUnit = `-- name: ListByUnit :many
SELECT 
    f.id, f.title, f.description, f.preview_message, f.message_after_submission, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at, f.visibility, f.google_sheet_url, f.publish_time, f.cover_image_url, f.dressing_color, f.dressing_header_font, f.dressing_question_font, f.dressing_text_font,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM forms f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
WHERE f.unit_id = $1
ORDER BY f.updated_at DESC
`

type ListByUnitRow struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	MessageAfterSubmission string
	Status                 Status
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Visibility             Visibility
	GoogleSheetUrl         pgtype.Text
	PublishTime            pgtype.Timestamptz
	CoverImageUrl          pgtype.Text
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
	UnitName               pgtype.Text
	OrgName                pgtype.Text
	LastEditorName         pgtype.Text
	LastEditorUsername     pgtype.Text
	LastEditorAvatarUrl    pgtype.Text
	LastEditorEmail        interface{}
}

func (q *Queries) ListByUnit(ctx context.Context, unitID pgtype.UUID) ([]ListByUnitRow, error) {
	rows, err := q.db.Query(ctx, listByUnit, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListByUnitRow
	for rows.Next() {
		var i ListByUnitRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.PreviewMessage,
			&i.MessageAfterSubmission,
			&i.Status,
			&i.UnitID,
			&i.LastEditor,
			&i.Deadline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Visibility,
			&i.GoogleSheetUrl,
			&i.PublishTime,
			&i.CoverImageUrl,
			&i.DressingColor,
			&i.DressingHeaderFont,
			&i.DressingQuestionFont,
			&i.DressingTextFont,
			&i.UnitName,
			&i.OrgName,
			&i.LastEditorName,
			&i.LastEditorUsername,
			&i.LastEditorAvatarUrl,
			&i.LastEditorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setStatus = `-- name: SetStatus :one
UPDATE forms
SET status = $2, last_editor = $3, updated_at = now()
WHERE id = $1
RETURNING id, title, description, preview_message, message_after_submission, status, unit_id, last_editor, deadline, created_at, updated_at, visibility, google_sheet_url, publish_time, cover_image_url, dressing_color, dressing_header_font, dressing_question_font, dressing_text_font
`

type SetStatusParams struct {
	ID         uuid.UUID
	Status     Status
	LastEditor uuid.UUID
}

func (q *Queries) SetStatus(ctx context.Context, arg SetStatusParams) (Form, error) {
	row := q.db.QueryRow(ctx, setStatus, arg.ID, arg.Status, arg.LastEditor)
	var i Form
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.MessageAfterSubmission,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Visibility,
		&i.GoogleSheetUrl,
		&i.PublishTime,
		&i.CoverImageUrl,
		&i.DressingColor,
		&i.DressingHeaderFont,
		&i.DressingQuestionFont,
		&i.DressingTextFont,
	)
	return i, err
}

const update = `-- name: Update :one
WITH updated AS (
    UPDATE forms
    SET
        title = $2,
        description = $3,
        preview_message = $4,
        last_editor = $5,
        deadline = $6,
        publish_time = $7,
        message_after_submission = $8,
        google_sheet_url = $9,
        visibility = $10,
        dressing_color = $11,
        dressing_header_font = $12,
        dressing_question_font = $13,
        dressing_text_font = $14,
        updated_at = now()
    WHERE forms.id = $1
    RETURNING id, title, description, preview_message, message_after_submission, status, unit_id, last_editor, deadline, created_at, updated_at, visibility, google_sheet_url, publish_time, cover_image_url, dressing_color, dressing_header_font, dressing_question_font, dressing_text_font
)
SELECT 
    f.id, f.title, f.description, f.preview_message, f.message_after_submission, f.status, f.unit_id, f.last_editor, f.deadline, f.created_at, f.updated_at, f.visibility, f.google_sheet_url, f.publish_time, f.cover_image_url, f.dressing_color, f.dressing_header_font, f.dressing_question_font, f.dressing_text_font,
    u.name as unit_name,
    o.name as org_name,
    usr.name as last_editor_name,
    usr.username as last_editor_username,
    usr.avatar_url as last_editor_avatar_url,
    usr.emails as last_editor_email
FROM updated f
LEFT JOIN units u ON f.unit_id = u.id
LEFT JOIN units o ON u.org_id = o.id
LEFT JOIN users_with_emails usr ON f.last_editor = usr.id
`

type UpdateParams struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	PublishTime            pgtype.Timestamptz
	MessageAfterSubmission string
	GoogleSheetUrl         pgtype.Text
	Visibility             Visibility
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
}

type UpdateRow struct {
	ID                     uuid.UUID
	Title                  string
	Description            pgtype.Text
	PreviewMessage         pgtype.Text
	MessageAfterSubmission string
	Status                 Status
	UnitID                 pgtype.UUID
	LastEditor             uuid.UUID
	Deadline               pgtype.Timestamptz
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	Visibility             Visibility
	GoogleSheetUrl         pgtype.Text
	PublishTime            pgtype.Timestamptz
	CoverImageUrl          pgtype.Text
	DressingColor          pgtype.Text
	DressingHeaderFont     pgtype.Text
	DressingQuestionFont   pgtype.Text
	DressingTextFont       pgtype.Text
	UnitName               pgtype.Text
	OrgName                pgtype.Text
	LastEditorName         pgtype.Text
	LastEditorUsername     pgtype.Text
	LastEditorAvatarUrl    pgtype.Text
	LastEditorEmail        interface{}
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (UpdateRow, error) {
	row := q.db.QueryRow(ctx, update,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.PreviewMessage,
		arg.LastEditor,
		arg.Deadline,
		arg.PublishTime,
		arg.MessageAfterSubmission,
		arg.GoogleSheetUrl,
		arg.Visibility,
		arg.DressingColor,
		arg.DressingHeaderFont,
		arg.DressingQuestionFont,
		arg.DressingTextFont,
	)
	var i UpdateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.PreviewMessage,
		&i.MessageAfterSubmission,
		&i.Status,
		&i.UnitID,
		&i.LastEditor,
		&i.Deadline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Visibility,
		&i.GoogleSheetUrl,
		&i.PublishTime,
		&i.CoverImageUrl,
		&i.DressingColor,
		&i.DressingHeaderFont,
		&i.DressingQuestionFont,
		&i.DressingTextFont,
		&i.UnitName,
		&i.OrgName,
		&i.LastEditorName,
		&i.LastEditorUsername,
		&i.LastEditorAvatarUrl,
		&i.LastEditorEmail,
	)
	return i, err
}

const uploadCoverImage = `-- name: UploadCoverImage :one
WITH upsert AS (
    INSERT INTO form_covers (form_id, image_data)
    VALUES ($1, $2)
    ON CONFLICT (form_id) DO UPDATE
        SET image_data = EXCLUDED.image_data,
            updated_at = now()
    RETURNING form_id
)
UPDATE forms
SET cover_image_url = $3,
    updated_at = now()
WHERE id = (SELECT form_id FROM upsert)
RETURNING id
`

type UploadCoverImageParams struct {
	FormID        uuid.UUID
	ImageData     []byte
	CoverImageUrl pgtype.Text
}

func (q *Queries) UploadCoverImage(ctx context.Context, arg UploadCoverImageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, uploadCoverImage, arg.FormID, arg.ImageData, arg.CoverImageUrl)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
