// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"NYCU-SDC/core-system-backend/internal/form/response"
	"context"

	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// AnswerExists provides a mock function for the type MockQuerier
func (_mock *MockQuerier) AnswerExists(ctx context.Context, arg response.AnswerExistsParams) (bool, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for AnswerExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.AnswerExistsParams) (bool, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.AnswerExistsParams) bool); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.AnswerExistsParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_AnswerExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AnswerExists'
type MockQuerier_AnswerExists_Call struct {
	*mock.Call
}

// AnswerExists is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.AnswerExistsParams
func (_e *MockQuerier_Expecter) AnswerExists(ctx interface{}, arg interface{}) *MockQuerier_AnswerExists_Call {
	return &MockQuerier_AnswerExists_Call{Call: _e.mock.On("AnswerExists", ctx, arg)}
}

func (_c *MockQuerier_AnswerExists_Call) Run(run func(ctx context.Context, arg response.AnswerExistsParams)) *MockQuerier_AnswerExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.AnswerExistsParams
		if args[1] != nil {
			arg1 = args[1].(response.AnswerExistsParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_AnswerExists_Call) Return(b bool, err error) *MockQuerier_AnswerExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockQuerier_AnswerExists_Call) RunAndReturn(run func(ctx context.Context, arg response.AnswerExistsParams) (bool, error)) *MockQuerier_AnswerExists_Call {
	_c.Call.Return(run)
	return _c
}

// CheckAnswerContent provides a mock function for the type MockQuerier
func (_mock *MockQuerier) CheckAnswerContent(ctx context.Context, arg response.CheckAnswerContentParams) (bool, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CheckAnswerContent")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CheckAnswerContentParams) (bool, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CheckAnswerContentParams) bool); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.CheckAnswerContentParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_CheckAnswerContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckAnswerContent'
type MockQuerier_CheckAnswerContent_Call struct {
	*mock.Call
}

// CheckAnswerContent is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.CheckAnswerContentParams
func (_e *MockQuerier_Expecter) CheckAnswerContent(ctx interface{}, arg interface{}) *MockQuerier_CheckAnswerContent_Call {
	return &MockQuerier_CheckAnswerContent_Call{Call: _e.mock.On("CheckAnswerContent", ctx, arg)}
}

func (_c *MockQuerier_CheckAnswerContent_Call) Run(run func(ctx context.Context, arg response.CheckAnswerContentParams)) *MockQuerier_CheckAnswerContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.CheckAnswerContentParams
		if args[1] != nil {
			arg1 = args[1].(response.CheckAnswerContentParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_CheckAnswerContent_Call) Return(b bool, err error) *MockQuerier_CheckAnswerContent_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockQuerier_CheckAnswerContent_Call) RunAndReturn(run func(ctx context.Context, arg response.CheckAnswerContentParams) (bool, error)) *MockQuerier_CheckAnswerContent_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Create(ctx context.Context, arg response.CreateParams) (response.FormResponse, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 response.FormResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CreateParams) (response.FormResponse, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CreateParams) response.FormResponse); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(response.FormResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.CreateParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockQuerier_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.CreateParams
func (_e *MockQuerier_Expecter) Create(ctx interface{}, arg interface{}) *MockQuerier_Create_Call {
	return &MockQuerier_Create_Call{Call: _e.mock.On("Create", ctx, arg)}
}

func (_c *MockQuerier_Create_Call) Run(run func(ctx context.Context, arg response.CreateParams)) *MockQuerier_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.CreateParams
		if args[1] != nil {
			arg1 = args[1].(response.CreateParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_Create_Call) Return(formResponse response.FormResponse, err error) *MockQuerier_Create_Call {
	_c.Call.Return(formResponse, err)
	return _c
}

func (_c *MockQuerier_Create_Call) RunAndReturn(run func(ctx context.Context, arg response.CreateParams) (response.FormResponse, error)) *MockQuerier_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAnswer provides a mock function for the type MockQuerier
func (_mock *MockQuerier) CreateAnswer(ctx context.Context, arg response.CreateAnswerParams) (response.Answer, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateAnswer")
	}

	var r0 response.Answer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CreateAnswerParams) (response.Answer, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.CreateAnswerParams) response.Answer); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(response.Answer)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.CreateAnswerParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_CreateAnswer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAnswer'
type MockQuerier_CreateAnswer_Call struct {
	*mock.Call
}

// CreateAnswer is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.CreateAnswerParams
func (_e *MockQuerier_Expecter) CreateAnswer(ctx interface{}, arg interface{}) *MockQuerier_CreateAnswer_Call {
	return &MockQuerier_CreateAnswer_Call{Call: _e.mock.On("CreateAnswer", ctx, arg)}
}

func (_c *MockQuerier_CreateAnswer_Call) Run(run func(ctx context.Context, arg response.CreateAnswerParams)) *MockQuerier_CreateAnswer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.CreateAnswerParams
		if args[1] != nil {
			arg1 = args[1].(response.CreateAnswerParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_CreateAnswer_Call) Return(answer response.Answer, err error) *MockQuerier_CreateAnswer_Call {
	_c.Call.Return(answer, err)
	return _c
}

func (_c *MockQuerier_CreateAnswer_Call) RunAndReturn(run func(ctx context.Context, arg response.CreateAnswerParams) (response.Answer, error)) *MockQuerier_CreateAnswer_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockQuerier_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockQuerier_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockQuerier_Expecter) Delete(ctx interface{}, id interface{}) *MockQuerier_Delete_Call {
	return &MockQuerier_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockQuerier_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockQuerier_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_Delete_Call) Return(err error) *MockQuerier_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockQuerier_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockQuerier_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Exists(ctx context.Context, arg response.ExistsParams) (bool, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.ExistsParams) (bool, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.ExistsParams) bool); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.ExistsParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockQuerier_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.ExistsParams
func (_e *MockQuerier_Expecter) Exists(ctx interface{}, arg interface{}) *MockQuerier_Exists_Call {
	return &MockQuerier_Exists_Call{Call: _e.mock.On("Exists", ctx, arg)}
}

func (_c *MockQuerier_Exists_Call) Run(run func(ctx context.Context, arg response.ExistsParams)) *MockQuerier_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.ExistsParams
		if args[1] != nil {
			arg1 = args[1].(response.ExistsParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_Exists_Call) Return(b bool, err error) *MockQuerier_Exists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockQuerier_Exists_Call) RunAndReturn(run func(ctx context.Context, arg response.ExistsParams) (bool, error)) *MockQuerier_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Get(ctx context.Context, arg response.GetParams) (response.FormResponse, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 response.FormResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetParams) (response.FormResponse, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetParams) response.FormResponse); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(response.FormResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.GetParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockQuerier_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.GetParams
func (_e *MockQuerier_Expecter) Get(ctx interface{}, arg interface{}) *MockQuerier_Get_Call {
	return &MockQuerier_Get_Call{Call: _e.mock.On("Get", ctx, arg)}
}

func (_c *MockQuerier_Get_Call) Run(run func(ctx context.Context, arg response.GetParams)) *MockQuerier_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.GetParams
		if args[1] != nil {
			arg1 = args[1].(response.GetParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_Get_Call) Return(formResponse response.FormResponse, err error) *MockQuerier_Get_Call {
	_c.Call.Return(formResponse, err)
	return _c
}

func (_c *MockQuerier_Get_Call) RunAndReturn(run func(ctx context.Context, arg response.GetParams) (response.FormResponse, error)) *MockQuerier_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetAnswerID provides a mock function for the type MockQuerier
func (_mock *MockQuerier) GetAnswerID(ctx context.Context, arg response.GetAnswerIDParams) (uuid.UUID, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetAnswerID")
	}

	var r0 uuid.UUID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetAnswerIDParams) (uuid.UUID, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetAnswerIDParams) uuid.UUID); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.GetAnswerIDParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_GetAnswerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAnswerID'
type MockQuerier_GetAnswerID_Call struct {
	*mock.Call
}

// GetAnswerID is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.GetAnswerIDParams
func (_e *MockQuerier_Expecter) GetAnswerID(ctx interface{}, arg interface{}) *MockQuerier_GetAnswerID_Call {
	return &MockQuerier_GetAnswerID_Call{Call: _e.mock.On("GetAnswerID", ctx, arg)}
}

func (_c *MockQuerier_GetAnswerID_Call) Run(run func(ctx context.Context, arg response.GetAnswerIDParams)) *MockQuerier_GetAnswerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.GetAnswerIDParams
		if args[1] != nil {
			arg1 = args[1].(response.GetAnswerIDParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_GetAnswerID_Call) Return(uUID uuid.UUID, err error) *MockQuerier_GetAnswerID_Call {
	_c.Call.Return(uUID, err)
	return _c
}

func (_c *MockQuerier_GetAnswerID_Call) RunAndReturn(run func(ctx context.Context, arg response.GetAnswerIDParams) (uuid.UUID, error)) *MockQuerier_GetAnswerID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAnswersByQuestionID provides a mock function for the type MockQuerier
func (_mock *MockQuerier) GetAnswersByQuestionID(ctx context.Context, arg response.GetAnswersByQuestionIDParams) ([]response.GetAnswersByQuestionIDRow, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetAnswersByQuestionID")
	}

	var r0 []response.GetAnswersByQuestionIDRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetAnswersByQuestionIDParams) ([]response.GetAnswersByQuestionIDRow, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetAnswersByQuestionIDParams) []response.GetAnswersByQuestionIDRow); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]response.GetAnswersByQuestionIDRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.GetAnswersByQuestionIDParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_GetAnswersByQuestionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAnswersByQuestionID'
type MockQuerier_GetAnswersByQuestionID_Call struct {
	*mock.Call
}

// GetAnswersByQuestionID is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.GetAnswersByQuestionIDParams
func (_e *MockQuerier_Expecter) GetAnswersByQuestionID(ctx interface{}, arg interface{}) *MockQuerier_GetAnswersByQuestionID_Call {
	return &MockQuerier_GetAnswersByQuestionID_Call{Call: _e.mock.On("GetAnswersByQuestionID", ctx, arg)}
}

func (_c *MockQuerier_GetAnswersByQuestionID_Call) Run(run func(ctx context.Context, arg response.GetAnswersByQuestionIDParams)) *MockQuerier_GetAnswersByQuestionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.GetAnswersByQuestionIDParams
		if args[1] != nil {
			arg1 = args[1].(response.GetAnswersByQuestionIDParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_GetAnswersByQuestionID_Call) Return(getAnswersByQuestionIDRows []response.GetAnswersByQuestionIDRow, err error) *MockQuerier_GetAnswersByQuestionID_Call {
	_c.Call.Return(getAnswersByQuestionIDRows, err)
	return _c
}

func (_c *MockQuerier_GetAnswersByQuestionID_Call) RunAndReturn(run func(ctx context.Context, arg response.GetAnswersByQuestionIDParams) ([]response.GetAnswersByQuestionIDRow, error)) *MockQuerier_GetAnswersByQuestionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetAnswersByResponseID provides a mock function for the type MockQuerier
func (_mock *MockQuerier) GetAnswersByResponseID(ctx context.Context, responseID uuid.UUID) ([]response.Answer, error) {
	ret := _mock.Called(ctx, responseID)

	if len(ret) == 0 {
		panic("no return value specified for GetAnswersByResponseID")
	}

	var r0 []response.Answer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]response.Answer, error)); ok {
		return returnFunc(ctx, responseID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []response.Answer); ok {
		r0 = returnFunc(ctx, responseID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]response.Answer)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, responseID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_GetAnswersByResponseID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAnswersByResponseID'
type MockQuerier_GetAnswersByResponseID_Call struct {
	*mock.Call
}

// GetAnswersByResponseID is a helper method to define mock.On call
//   - ctx context.Context
//   - responseID uuid.UUID
func (_e *MockQuerier_Expecter) GetAnswersByResponseID(ctx interface{}, responseID interface{}) *MockQuerier_GetAnswersByResponseID_Call {
	return &MockQuerier_GetAnswersByResponseID_Call{Call: _e.mock.On("GetAnswersByResponseID", ctx, responseID)}
}

func (_c *MockQuerier_GetAnswersByResponseID_Call) Run(run func(ctx context.Context, responseID uuid.UUID)) *MockQuerier_GetAnswersByResponseID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_GetAnswersByResponseID_Call) Return(answers []response.Answer, err error) *MockQuerier_GetAnswersByResponseID_Call {
	_c.Call.Return(answers, err)
	return _c
}

func (_c *MockQuerier_GetAnswersByResponseID_Call) RunAndReturn(run func(ctx context.Context, responseID uuid.UUID) ([]response.Answer, error)) *MockQuerier_GetAnswersByResponseID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByFormIDAndSubmittedBy provides a mock function for the type MockQuerier
func (_mock *MockQuerier) GetByFormIDAndSubmittedBy(ctx context.Context, arg response.GetByFormIDAndSubmittedByParams) (response.FormResponse, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetByFormIDAndSubmittedBy")
	}

	var r0 response.FormResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetByFormIDAndSubmittedByParams) (response.FormResponse, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.GetByFormIDAndSubmittedByParams) response.FormResponse); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(response.FormResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.GetByFormIDAndSubmittedByParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_GetByFormIDAndSubmittedBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByFormIDAndSubmittedBy'
type MockQuerier_GetByFormIDAndSubmittedBy_Call struct {
	*mock.Call
}

// GetByFormIDAndSubmittedBy is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.GetByFormIDAndSubmittedByParams
func (_e *MockQuerier_Expecter) GetByFormIDAndSubmittedBy(ctx interface{}, arg interface{}) *MockQuerier_GetByFormIDAndSubmittedBy_Call {
	return &MockQuerier_GetByFormIDAndSubmittedBy_Call{Call: _e.mock.On("GetByFormIDAndSubmittedBy", ctx, arg)}
}

func (_c *MockQuerier_GetByFormIDAndSubmittedBy_Call) Run(run func(ctx context.Context, arg response.GetByFormIDAndSubmittedByParams)) *MockQuerier_GetByFormIDAndSubmittedBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.GetByFormIDAndSubmittedByParams
		if args[1] != nil {
			arg1 = args[1].(response.GetByFormIDAndSubmittedByParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_GetByFormIDAndSubmittedBy_Call) Return(formResponse response.FormResponse, err error) *MockQuerier_GetByFormIDAndSubmittedBy_Call {
	_c.Call.Return(formResponse, err)
	return _c
}

func (_c *MockQuerier_GetByFormIDAndSubmittedBy_Call) RunAndReturn(run func(ctx context.Context, arg response.GetByFormIDAndSubmittedByParams) (response.FormResponse, error)) *MockQuerier_GetByFormIDAndSubmittedBy_Call {
	_c.Call.Return(run)
	return _c
}

// ListByFormID provides a mock function for the type MockQuerier
func (_mock *MockQuerier) ListByFormID(ctx context.Context, formID uuid.UUID) ([]response.FormResponse, error) {
	ret := _mock.Called(ctx, formID)

	if len(ret) == 0 {
		panic("no return value specified for ListByFormID")
	}

	var r0 []response.FormResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]response.FormResponse, error)); ok {
		return returnFunc(ctx, formID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []response.FormResponse); ok {
		r0 = returnFunc(ctx, formID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]response.FormResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, formID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_ListByFormID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByFormID'
type MockQuerier_ListByFormID_Call struct {
	*mock.Call
}

// ListByFormID is a helper method to define mock.On call
//   - ctx context.Context
//   - formID uuid.UUID
func (_e *MockQuerier_Expecter) ListByFormID(ctx interface{}, formID interface{}) *MockQuerier_ListByFormID_Call {
	return &MockQuerier_ListByFormID_Call{Call: _e.mock.On("ListByFormID", ctx, formID)}
}

func (_c *MockQuerier_ListByFormID_Call) Run(run func(ctx context.Context, formID uuid.UUID)) *MockQuerier_ListByFormID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_ListByFormID_Call) Return(formResponses []response.FormResponse, err error) *MockQuerier_ListByFormID_Call {
	_c.Call.Return(formResponses, err)
	return _c
}

func (_c *MockQuerier_ListByFormID_Call) RunAndReturn(run func(ctx context.Context, formID uuid.UUID) ([]response.FormResponse, error)) *MockQuerier_ListByFormID_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockQuerier
func (_mock *MockQuerier) Update(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockQuerier_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockQuerier_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockQuerier_Expecter) Update(ctx interface{}, id interface{}) *MockQuerier_Update_Call {
	return &MockQuerier_Update_Call{Call: _e.mock.On("Update", ctx, id)}
}

func (_c *MockQuerier_Update_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockQuerier_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_Update_Call) Return(err error) *MockQuerier_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockQuerier_Update_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockQuerier_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAnswer provides a mock function for the type MockQuerier
func (_mock *MockQuerier) UpdateAnswer(ctx context.Context, arg response.UpdateAnswerParams) (response.Answer, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAnswer")
	}

	var r0 response.Answer
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.UpdateAnswerParams) (response.Answer, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, response.UpdateAnswerParams) response.Answer); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(response.Answer)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, response.UpdateAnswerParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockQuerier_UpdateAnswer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAnswer'
type MockQuerier_UpdateAnswer_Call struct {
	*mock.Call
}

// UpdateAnswer is a helper method to define mock.On call
//   - ctx context.Context
//   - arg response.UpdateAnswerParams
func (_e *MockQuerier_Expecter) UpdateAnswer(ctx interface{}, arg interface{}) *MockQuerier_UpdateAnswer_Call {
	return &MockQuerier_UpdateAnswer_Call{Call: _e.mock.On("UpdateAnswer", ctx, arg)}
}

func (_c *MockQuerier_UpdateAnswer_Call) Run(run func(ctx context.Context, arg response.UpdateAnswerParams)) *MockQuerier_UpdateAnswer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 response.UpdateAnswerParams
		if args[1] != nil {
			arg1 = args[1].(response.UpdateAnswerParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockQuerier_UpdateAnswer_Call) Return(answer response.Answer, err error) *MockQuerier_UpdateAnswer_Call {
	_c.Call.Return(answer, err)
	return _c
}

func (_c *MockQuerier_UpdateAnswer_Call) RunAndReturn(run func(ctx context.Context, arg response.UpdateAnswerParams) (response.Answer, error)) *MockQuerier_UpdateAnswer_Call {
	_c.Call.Return(run)
	return _c
}
