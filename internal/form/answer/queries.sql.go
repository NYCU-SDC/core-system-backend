// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package answer

import (
	"context"

	"github.com/google/uuid"
)

const batchUpsert = `-- name: BatchUpsert :many
INSERT INTO answers (response_id, question_id, value)
SELECT
    unnest($1::uuid []),
    unnest($2::uuid []),
    unnest($3::jsonb [])
ON CONFLICT (response_id, question_id)
DO UPDATE
    SET
        value = excluded.value,
        updated_at = now()
    WHERE answers.value IS DISTINCT FROM excluded.value
RETURNING id, response_id, question_id, value, created_at, updated_at
`

type BatchUpsertParams struct {
	ResponseIds []uuid.UUID
	QuestionIds []uuid.UUID
	Values      [][]byte
}

func (q *Queries) BatchUpsert(ctx context.Context, arg BatchUpsertParams) ([]Answer, error) {
	rows, err := q.db.Query(ctx, batchUpsert, arg.ResponseIds, arg.QuestionIds, arg.Values)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.QuestionID,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const create = `-- name: Create :one
INSERT INTO answers (response_id, question_id, value)
VALUES ($1, $2, $3)
RETURNING id, response_id, question_id, value, created_at, updated_at
`

type CreateParams struct {
	ResponseID uuid.UUID
	QuestionID uuid.UUID
	Value      []byte
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (Answer, error) {
	row := q.db.QueryRow(ctx, create, arg.ResponseID, arg.QuestionID, arg.Value)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.QuestionID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteByResponseID = `-- name: DeleteByResponseID :exec
DELETE FROM answers
WHERE response_id = $1
`

func (q *Queries) DeleteByResponseID(ctx context.Context, responseID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteByResponseID, responseID)
	return err
}

const get = `-- name: Get :one
SELECT id FROM answers
WHERE response_id = $1 AND question_id = $2
`

type GetParams struct {
	ResponseID uuid.UUID
	QuestionID uuid.UUID
}

func (q *Queries) Get(ctx context.Context, arg GetParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, get, arg.ResponseID, arg.QuestionID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getByResponseIDAndQuestionID = `-- name: GetByResponseIDAndQuestionID :one
SELECT id, response_id, question_id, value, created_at, updated_at FROM answers
WHERE response_id = $1 AND question_id = $2
`

type GetByResponseIDAndQuestionIDParams struct {
	ResponseID uuid.UUID
	QuestionID uuid.UUID
}

func (q *Queries) GetByResponseIDAndQuestionID(ctx context.Context, arg GetByResponseIDAndQuestionIDParams) (Answer, error) {
	row := q.db.QueryRow(ctx, getByResponseIDAndQuestionID, arg.ResponseID, arg.QuestionID)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.QuestionID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listByQuestionIDAndResponseID = `-- name: ListByQuestionIDAndResponseID :one
SELECT id, response_id, question_id, value, created_at, updated_at FROM answers
WHERE question_id = $1 AND response_id = $2
ORDER BY created_at ASC
`

type ListByQuestionIDAndResponseIDParams struct {
	QuestionID uuid.UUID
	ResponseID uuid.UUID
}

func (q *Queries) ListByQuestionIDAndResponseID(ctx context.Context, arg ListByQuestionIDAndResponseIDParams) (Answer, error) {
	row := q.db.QueryRow(ctx, listByQuestionIDAndResponseID, arg.QuestionID, arg.ResponseID)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.QuestionID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listByResponseID = `-- name: ListByResponseID :many
SELECT id, response_id, question_id, value, created_at, updated_at FROM answers
WHERE response_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListByResponseID(ctx context.Context, responseID uuid.UUID) ([]Answer, error) {
	rows, err := q.db.Query(ctx, listByResponseID, responseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.QuestionID,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update = `-- name: Update :one
UPDATE answers
SET value = $2, updated_at = now()
WHERE id = $1
RETURNING id, response_id, question_id, value, created_at, updated_at
`

type UpdateParams struct {
	ID    uuid.UUID
	Value []byte
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (Answer, error) {
	row := q.db.QueryRow(ctx, update, arg.ID, arg.Value)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.QuestionID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsert = `-- name: Upsert :one
INSERT INTO answers (response_id, question_id, value)
VALUES ($1, $2, $3)
    ON CONFLICT (response_id, question_id)
DO UPDATE SET
           value = excluded.value,
           updated_at = CASE
           WHEN answers.value IS DISTINCT FROM excluded.value
           THEN now()
           ELSE answers.updated_at
END
RETURNING id, response_id, question_id, value, created_at, updated_at
`

type UpsertParams struct {
	ResponseID uuid.UUID
	QuestionID uuid.UUID
	Value      []byte
}

func (q *Queries) Upsert(ctx context.Context, arg UpsertParams) (Answer, error) {
	row := q.db.QueryRow(ctx, upsert, arg.ResponseID, arg.QuestionID, arg.Value)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.QuestionID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
